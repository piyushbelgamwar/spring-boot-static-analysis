public ValidationErrorResponse performAsyncSchemaValidation(InputStream inputStream, DataProcessingInfo dpInfo) {
    List<ValidationError> validationErrorsList = new ArrayList();
    String dataItemWithVersion;
    if (dpInfo.getFilePath() == null) {
        dataItemWithVersion = this.dataItemVersionService.getDataItemVersionFromUrlPath(dpInfo);
    } else {
        dataItemWithVersion = dpInfo.getFilePath();
    }

    LOGGER.info("Data Item Version is {}", dataItemWithVersion);

    try {
        // Create a copy of the input stream so we can read it multiple times
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len;
        while ((len = inputStream.read(buffer)) > -1) {
            baos.write(buffer, 0, len);
        }
        byte[] xmlBytes = baos.toByteArray();
        
        // First, check for empty elements by converting to string
        String xmlContent = new String(xmlBytes, StandardCharsets.UTF_8);
        checkForEmptyElements(xmlContent, validationErrorsList, dpInfo);
        
        // Then, proceed with normal schema validation
        ByteArrayInputStream inputStreamForValidation = new ByteArrayInputStream(xmlBytes);
        
        System.setProperty("javax.xml.transform.TransformerFactory", "com.saxonica.config.EnterpriseTransformerFactory");
        TransformerFactory transformerFactory = CommonUtility.getTransformerFactory();
        String stringSchemaFile = this.dataItemVersionService.getStringFileNameByVersionAndExtension(dataItemWithVersion, this.schemaFileSuffix, dpInfo);
        LOGGER.info("stringSchemaFile = {}", stringSchemaFile);
        StreamSource specific = new StreamSource(this.getClass().getClassLoader().getResource(stringSchemaFile).toExternalForm());
        ((EnterpriseTransformerFactory)transformerFactory).addSchema(specific);
        Transformer trans = transformerFactory.newTransformer();
        StreamSource source = new StreamSource(inputStreamForValidation);
        SAXResult sink = new SAXResult(new DefaultHandler());
        trans.setErrorListener(new SchemaErrorListener(validationErrorsList, dpInfo));
        trans.transform(source, sink);
    } catch (Exception var12) {
        Exception e = var12;
        LOGGER.error("Error Processing Schema Validation ", e);
        throw new SchemaValidationException("Error in schema validation", e);
    }

    if (!validationErrorsList.isEmpty()) {
        return new ValidationErrorResponse(validationErrorsList);
    } else {
        LOGGER.info("Schema level validation completed");
        return null;
    }
}

private void checkForEmptyElements(String xmlContent, List<ValidationError> validationErrorsList, DataProcessingInfo dpInfo) {
    // Map of elements that must have content and their reference IDs
    Map<String, String> requiredElements = new HashMap<>();
    requiredElements.put("BUID", "1A");
    requiredElements.put("Brand", "5A");
    requiredElements.put("SortCode", "6A");
    requiredElements.put("Postcode", "9A");
    requiredElements.put("Address", "10A");
    requiredElements.put("Easting", "11A");
    requiredElements.put("Northing", "12A");
    
    // Using regex to find elements with whitespace-only content
    for (Map.Entry<String, String> entry : requiredElements.entrySet()) {
        String elementName = entry.getKey();
        String elementRef = entry.getValue();
        String pattern = "<" + elementName + ">\\s*</" + elementName + ">";
        
        // Find all matches of this element with whitespace-only content
        Pattern regex = Pattern.compile(pattern);
        Matcher matcher = regex.matcher(xmlContent);
        
        if (matcher.find()) {
            // Create validation error for this empty element
            ValidationError error = new ValidationError();
            error.setType("Schema");
            error.setElementRef(elementRef);
            error.setElement("REP026a-AccesstoCashBanksandBuildingSocieties.BranchInformation." + elementName);
            error.setDescription("BUID001100: This field must be completed.");
            validationErrorsList.add(error);
        }
    }
}
