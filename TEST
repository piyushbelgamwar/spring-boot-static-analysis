@Trace
@Consumes({"application/xml"})
@PutMapping("/REP/REP026a/schemaAndBusinessValidationForAsyncProcess/v1")
public ResponseEntity<ValidateDataItemResponse> schemaAndBusinessValidationForAsyncProcess(
        @RequestBody Map<String, Object> requestParameterMap, @RequestHeader Map<String, String> headers) throws ClassNotFoundException, XMLStreamException, ParseException, IOException {

    LOGGER.info("Inside REP026aApiController > schemaAndBusinessValidationForAsyncProcess");
    DataProcessingInfo dataProcessingObj = getDataProcessingObj(headers);
    dataProcessingObj.setValidationType(Constants.SCHEMA);
    requestParameterMap.put("repAsyncDataItems", repAsyncDataItems);
    XmlUploadDataRequest xmlUploadDataRequest = new ObjectMapper().convertValue(requestParameterMap.get("xmlUploadDataRequest"), XmlUploadDataRequest.class);
    
    // Get the file path
    String filePath = "C:\\Users\\PBelgamwar\\Downloads\\REP026a_Test 2.xml";
    
    // Read the file and convert to String
    InputStream inputStream = Files.newInputStream(Paths.get(filePath));
    String xmlContent = IOUtils.toString(inputStream, StandardCharsets.UTF_8);
    inputStream.close();
    
    // Set XML content in dataProcessingObj to use same pathway as regular validation
    dataProcessingObj.setXmlContent(xmlContent);
    
    // Create new InputStream from the String for processing
    InputStream processInputStream = IOUtils.toInputStream(xmlContent, StandardCharsets.UTF_8);
    
    // Process with the enriched dataProcessingObj
    ValidateDataItemResponse validateDataItemResponse = applicationService.processAsyncXmlUpload(processInputStream, requestParameterMap, dataProcessingObj, headers);
    
    try {
        processInputStream.close();
    } catch (IOException e) {
        LOGGER.error("Exception in closing inputStream :: {}", e);
    }

    if (validateDataItemResponse != null && validateDataItemResponse.getCompletionStatus().equalsIgnoreCase(REPConstants.SCHEMA_PASSED)) {
        dataProcessingObj.setValidationType(Constants.BUSINESS);
        InputStream inputStream1 = Files.newInputStream(Paths.get(filePath));
        validateDataItemResponse = readLargeXMLFiles.performBusinessValidations(inputStream1, validateDataItemResponse.getFirmDataItemId());
        if (validateDataItemResponse != null) {
            if (REPConstants.READY_TO_SUBMIT.equalsIgnoreCase(validateDataItemResponse.getCompletionStatus()))
                emailNotificationService.sendEmail(xmlUploadDataRequest, REPConstants.A2C_VALIDATION_SUCCCESSFUL_HTML, headers.get("useremail"), dataProcessingObj);
            else
                emailNotificationService.sendEmail(xmlUploadDataRequest, REPConstants.A2C_VALIDATION_FAILURE_HTML, headers.get("useremail"), dataProcessingObj);
        }
    } else {
        RepUtility.splittingSchemaMessage(validateDataItemResponse);
        validateDataItemResponse.getValidationErrorResponse().get(0).setValidationErrors(RepUtility.modifySchemaMessageForPostCode(validateDataItemResponse));
        InputStream inputStream1 = Files.newInputStream(Paths.get(filePath));
        readLargeXMLFiles.fetchUniqueIdsForLargeXMLs(inputStream1, validateDataItemResponse, REPConstants.BRANCH_INFORMATION_BUID);
        try {
            inputStream1.close();
        } catch (IOException e) {
            LOGGER.error("Exception in closing inputStream :: {}", e);
        }
    }

    return new ResponseEntity<>(validateDataItemResponse, HttpStatus.OK);
}
