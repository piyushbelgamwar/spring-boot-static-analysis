import java.io.*;
import java.nio.file.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class KeywordSearcher {
    
    // Restrict file types to only these extensions
    private static final Set<String> ALLOWED_FILE_EXTENSIONS = new HashSet<>(Arrays.asList(
            ".java", ".xml", ".yaml", ".yml", ".properties"
    ));
    
    private static final Object printLock = new Object();
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get folder path from user
        System.out.println("Enter the root folder path to search in:");
        String rootFolderPath = scanner.nextLine().trim();
        
        // Get keyword from user
        System.out.println("Enter the keyword to search for:");
        String keyword = scanner.nextLine().trim();
        
        File rootFolder = new File(rootFolderPath);
        if (!rootFolder.exists() || !rootFolder.isDirectory()) {
            System.out.println("Error: The specified path does not exist or is not a directory.");
            scanner.close();
            return;
        }
        
        System.out.println("Searching for keyword: \"" + keyword + "\" in " + rootFolderPath);
        System.out.println("Scanning only files with extensions: " + String.join(", ", ALLOWED_FILE_EXTENSIONS));
        System.out.println("----------------------------------------------------");
        
        // Create result file
        String resultFilePath = "keyword_search_results.txt";
        try (PrintWriter writer = new PrintWriter(new FileWriter(resultFilePath))) {
            writer.println("Search Results for keyword: \"" + keyword + "\"");
            writer.println("Root folder: " + rootFolderPath);
            writer.println("File types scanned: " + String.join(", ", ALLOWED_FILE_EXTENSIONS));
            writer.println("Date: " + new Date());
            writer.println("----------------------------------------------------");
            
            // Start the search
            long startTime = System.currentTimeMillis();
            Map<String, ModuleSearchStats> moduleStats = new ConcurrentHashMap<>();
            List<SearchResult> results = searchKeywordInFolder(rootFolder, keyword, moduleStats);
            long endTime = System.currentTimeMillis();
            
            // Print module statistics
            System.out.println("\n----------------------------------------------------");
            System.out.println("MODULE STATISTICS");
            System.out.println("----------------------------------------------------");
            
            moduleStats.forEach((moduleName, stats) -> {
                System.out.println("Module: " + moduleName + " --> " + stats.getFileCount() + " files scanned");
                writer.println("Module: " + moduleName + " --> " + stats.getFileCount() + " files scanned");
            });
            
            // Sort results by module and file name
            results.sort(Comparator.comparing(SearchResult::getModuleName)
                    .thenComparing(SearchResult::getFileName));
            
            // Print and write results
            System.out.println("\n----------------------------------------------------");
            System.out.println("SEARCH RESULTS");
            System.out.println("----------------------------------------------------");
            
            if (results.isEmpty()) {
                System.out.println("No occurrences of the keyword found.");
                writer.println("\nNo occurrences of the keyword found.");
            } else {
                String currentModule = "";
                
                for (SearchResult result : results) {
                    // Print module header if we're in a new module
                    if (!result.getModuleName().equals(currentModule)) {
                        currentModule = result.getModuleName();
                        System.out.println("\nModule: " + currentModule);
                    }
                    
                    // Print the result to console
                    System.out.println("  File: " + result.getFileName() + ", Line: " + result.getLineNumber());
                    
                    // Write the result to file
                    writer.println("Module: " + result.getModuleName() + 
                                   ", File: " + result.getFileName() + 
                                   ", Line: " + result.getLineNumber() +
                                   ", Content: " + result.getLineContent().trim());
                }
                
                System.out.println("\n----------------------------------------------------");
                System.out.println("Total occurrences found: " + results.size());
            }
            
            System.out.println("Search completed in " + (endTime - startTime) + " ms");
            writer.println("\n----------------------------------------------------");
            writer.println("Total occurrences found: " + results.size());
            writer.println("Search completed in " + (endTime - startTime) + " ms");
            
            System.out.println("Results have been saved to: " + new File(resultFilePath).getAbsolutePath());
            
        } catch (IOException e) {
            System.err.println("Error writing to result file: " + e.getMessage());
        } finally {
            scanner.close();
        }
    }
    
    private static List<SearchResult> searchKeywordInFolder(File rootFolder, String keyword, 
                                                          Map<String, ModuleSearchStats> moduleStats) {
        List<SearchResult> results = Collections.synchronizedList(new ArrayList<>());
        
        // Get all modules (directories) from the root folder
        File[] modules = rootFolder.listFiles(File::isDirectory);
        
        if (modules == null || modules.length == 0) {
            System.out.println("No modules found in the root directory.");
            return results;
        }
        
        // Create a thread pool for parallel processing
        int numThreads = Math.min(Runtime.getRuntime().availableProcessors(), modules.length);
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        
        try {
            List<Future<?>> futures = new ArrayList<>();
            
            // Process each module in parallel
            for (File module : modules) {
                String moduleName = module.getName();
                moduleStats.put(moduleName, new ModuleSearchStats());
                
                futures.add(executor.submit(() -> {
                    try {
                        processModule(module, keyword, results, moduleStats.get(moduleName));
                    } catch (Exception e) {
                        System.err.println("Error processing module " + moduleName + ": " + e.getMessage());
                    }
                }));
            }
            
            // Wait for all tasks to complete
            for (Future<?> future : futures) {
                try {
                    future.get();
                } catch (Exception e) {
                    System.err.println("Error in search task: " + e.getMessage());
                }
            }
        } finally {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
        
        return results;
    }
    
    private static void processModule(File module, String keyword, List<SearchResult> results, 
                                     ModuleSearchStats stats) {
        String moduleName = module.getName();
        
        // Print the module name being searched
        synchronized(printLock) {
            System.out.println("Searching module: " + moduleName);
        }
        
        try {
            Files.walk(module.toPath())
                .filter(Files::isRegularFile)
                .filter(path -> isAllowedFileType(path.toString()))
                .forEach(path -> {
                    stats.incrementFileCount();
                    try {
                        processFile(path.toFile(), moduleName, keyword, results);
                    } catch (IOException e) {
                        System.err.println("Error processing file " + path + ": " + e.getMessage());
                    }
                });
        } catch (IOException e) {
            System.err.println("Error walking directory " + module + ": " + e.getMessage());
        }
    }
    
    private static boolean isAllowedFileType(String filePath) {
        String lowerCasePath = filePath.toLowerCase();
        return ALLOWED_FILE_EXTENSIONS.stream().anyMatch(lowerCasePath::endsWith);
    }
    
    private static void processFile(File file, String moduleName, String keyword, List<SearchResult> results) 
            throws IOException {
        String fileName = file.getName();
        
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(
                new FileInputStream(file), StandardCharsets.UTF_8))) {
            
            String line;
            int lineNumber = 0;
            
            while ((line = reader.readLine()) != null) {
                lineNumber++;
                
                if (line.contains(keyword)) {
                    results.add(new SearchResult(moduleName, fileName, lineNumber, line));
                }
            }
        }
    }
    
    static class ModuleSearchStats {
        private final AtomicInteger fileCount = new AtomicInteger(0);
        
        public void incrementFileCount() {
            fileCount.incrementAndGet();
        }
        
        public int getFileCount() {
            return fileCount.get();
        }
    }
    
    static class SearchResult {
        private final String moduleName;
        private final String fileName;
        private final int lineNumber;
        private final String lineContent;
        
        public SearchResult(String moduleName, String fileName, int lineNumber, String lineContent) {
            this.moduleName = moduleName;
            this.fileName = fileName;
            this.lineNumber = lineNumber;
            this.lineContent = lineContent;
        }
        
        public String getModuleName() {
            return moduleName;
        }
        
        public String getFileName() {
            return fileName;
        }
        
        public int getLineNumber() {
            return lineNumber;
        }
        
        public String getLineContent() {
            return lineContent;
        }
    }
}
